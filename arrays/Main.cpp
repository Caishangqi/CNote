#include <iostream>
#include <array>

int main(int argc, char* argv[])
{

	//example 是一个整数指针
	int example[5]; //分配了足够的空间来储存5个整数

	int* ptr = example;

	/*
	 * 如果你设置了越界，那么你修改了不属于这个数组内存范围对应的值，
	 * 会导致违规操作
	 */

	for (int i = 0; i < 5; i++)
		/*
		 * 当我们去访问索引时，它对这个内存进行偏移，
		 * 首先寻找开始的内存地址并且每次往后加 8
		 */
		example[i] = 2;

	example[2] = 5;
	/*
	 * 指针算数， +2 取决于指针类型，这里是 2 x 4 = 8
	 * 这里的ptr是起始地址， 加多少是从这个地址往后加
	 * |02 00 00 00 02 00 00 00 /05/ 00 00 00 02 00 00 00 02 00 00 00 （ | 代表指针)
	 * 找到数组起始地址 0x0000002B96CFF548 在这偏移8字节
	 * 02 00 00 00 02 00 00 00 |05 00 00 00 02 00 00 00 02 00 00 00
	 */
	*(ptr + 2) = 6; //02 00 00 00 02 00 00 00 /06/ 00 00 00 02 00 00 00 02 00 00 00
	/*
	 * 指针类型设置成char 1 字节，则需要偏移 8 来达到 2号位置
	 * 02 00 00 00 02 00 00 00 /06/ 00 00 00 02 00 00 00 02 00 00 00
	 */
	*(int*) *((char*) (ptr)+8) = 6; //最后要把它转成int类型的指针

	//02 00 00 00 02 00 00 00 02 00 00 00 02 00 00 00 02 00 00 00
	/*
	 * 数组在内存中是连续的 02 00 00 00 是一个整数，每个整数是4个字节，
	 * 在5个整数大小的数组是连续20字节的内存
	 */
	std::cout << example[0] << std::endl;

	/*
	 * 你也可以在heap上创建Array，使用new 关键词,
	 * 不像创建在stack上的东西到结尾就会被摧毁, 创建
	 * 在heap上的必须我们手动销毁他或者直到程序结束，
	 * 寿命不一样
	 */

	int* another = new int[5];
	delete[] another;

	/*
	 * C++ 11 的新Array，能告诉你大小的
	 * 默认的array你sizeof如果在stack上创建它会返回数据字节总大小
	 * 例如 5 就是 20
	 * 如果你的array在heap上创建，则sizeof会返回指针字节大小也就是
	 * 4 因为int是4个字节大小
	 */

	std::array<int, 5> anotherLibArray;

	std::cin.get();
}
